================================================================================
                    MOFDiff + NH3 GUIDED GENERATION: COMPLETE PIPELINE
================================================================================

================================================================================
                                   OVERVIEW
================================================================================

    +----------------+    +----------------+    +----------------+    +----------------+
    | PREPROCESSING  | -> |   TRAINING     | -> |  GENERATION    | -> | POST-PROCESS   |
    +----------------+    +----------------+    +----------------+    +----------------+
    
    - MOF -> Graph        - VAE Encoder      - Latent Sampling    - Assembly
    - Building Blocks     - Diffusion        - NH3 Guidance       - Relaxation
    - LMDB Dataset        - NH3 Head         - Decoding           - Validation


================================================================================
                         PHASE 1: PREPROCESSING
================================================================================

1.1 RAW MOF DATA COLLECTION
--------------------------------------------------------------------------------
INPUT: CIF Files (Crystallographic Information Files)
Source: CoRE MOF Database, BWDB, etc.

    raw_nh3_core/cifs/
    ├── ABEXIQ.cif     (MOF structure 1)
    ├── ABEXOW.cif     (MOF structure 2)
    ├── ...
    └── ZZZZZ.cif      (MOF structure N)

    + NH3 uptake data (from GCMC simulations):
      nh3_core_structured.csv
      ┌─────────┬─────────────────────────────┐
      │ refcode │ NH3_uptake_298K_1bar [mmol/g]│
      ├─────────┼─────────────────────────────┤
      │ ABEXIQ  │ 8.503474                    │
      │ ABEXOW  │ 8.171084                    │
      └─────────┴─────────────────────────────┘


1.2 BUILDING BLOCK DECOMPOSITION
--------------------------------------------------------------------------------
SCRIPT: mofdiff/preprocessing/extract_mofid.py

    MOF Crystal Structure
           |
           v
    +---------------------------------------------+
    |         MOFid Decomposition                  |
    |  (Identifies topology & building blocks)    |
    +---------------------------------------------+
           |
           v
    +---------------------------------------------+
    |  Building Blocks (BBs):                      |
    |  - Metal Nodes (e.g., Cu paddlewheel)       |
    |  - Organic Linkers (e.g., BDC, BTC)         |
    |  - Functional Groups                         |
    +---------------------------------------------+

    Example BB:
         O    O
          \  /
     Cu--O-C-O--Cu    (Paddlewheel SBU)
          /  \
         O    O


1.3 COARSE-GRAINING (CG) REPRESENTATION
--------------------------------------------------------------------------------
SCRIPT: mofdiff/preprocessing/preprocess.py

    Atomic MOF  --->  Coarse-Grained MOF

    BEFORE (Atomic):           AFTER (Coarse-Grained):

      H   H                         [BB1]
       \ /                            |
    O=C-C=O                      ----+----
       |                              |
      Cu-Cu          -->          [Metal]
       |                              |
    O=C-C=O                      ----+----
       / \                            |
      H   H                         [BB2]

    Each Building Block --> Single "Super-atom"
    With properties:
    - Position (x, y, z)
    - Type (metal node, linker, etc.)
    - Orientation (rotation matrix)
    - Connection points


1.4 GRAPH CONSTRUCTION
--------------------------------------------------------------------------------
OUTPUT: PyTorch Geometric Data Objects

    For each MOF, create a graph:

    Data(
      x = [N, D_node],        # Node features (BB embeddings)
      edge_index = [2, E],    # Edge connectivity
      edge_attr = [E, D_edge],# Edge features (distances, etc.)
      pos = [N, 3],           # 3D positions
      cell = [3, 3],          # Unit cell parameters
      num_atoms = N,          # Number of CG beads
      ...
    )

    Graph Structure:

         [Node1]----edge----[Node2]
            |                  |
          edge              edge
            |                  |
         [Node3]----edge----[Node4]


1.5 LMDB DATASET CREATION
--------------------------------------------------------------------------------
SCRIPT: mofdiff/preprocessing/preprocess.py
OUTPUT: data/lmdbs/

    LMDB (Lightning Memory-Mapped Database)
    ├── train.lmdb    (Training set)
    ├── val.lmdb      (Validation set)
    └── test.lmdb     (Test set)

    Why LMDB?
    - Fast random access
    - Memory-mapped (doesn't load all into RAM)
    - Efficient for large datasets

    Each entry:
    key: MOF_id (e.g., "ABEXIQ")
    value: Serialized PyG Data object


================================================================================
                         PHASE 2: MODEL TRAINING
================================================================================

2.1 BUILDING BLOCK ENCODER TRAINING
--------------------------------------------------------------------------------
SCRIPT: Train BB Encoder (GNN-based)
CHECKPOINT: pretrained/bbencoder_ckpt/

    Purpose: Learn embeddings for each building block type

    +-------------------+
    |  Building Block   |
    |  (Atomic Graph)   |
    +---------+---------+
              |
              v
    +-------------------+
    |  GNN Encoder      |
    |  (Message         |
    |   Passing)        |
    +---------+---------+
              |
              v
    +-------------------+
    |  BB Embedding     |  z_bb ∈ R^128
    |  (Fixed-size      |
    |   vector)         |
    +-------------------+

    OUTPUT: pretrained/bb_emb_space.pt
    Contains: (all_bb_data, all_bb_embeddings)
    - ~10,000 unique building blocks
    - Each with 128-dim embedding


2.2 MOFDiff VAE + DIFFUSION TRAINING
--------------------------------------------------------------------------------
SCRIPT: python mofdiff/run.py
CHECKPOINT: pretrained/mofdiff_ckpt/

    Architecture: VAE + Denoising Diffusion

    +===========================================================+
    |                      ENCODER                               |
    |  +---------+    +---------+    +---------+                |
    |  | CG MOF  | -> |  GNN    | -> |  μ, σ   |                |
    |  | Graph   |    | Encoder |    |         |                |
    |  +---------+    +---------+    +----+----+                |
    |                                     |                      |
    |                          z = μ + σ·ε (reparameterize)     |
    |                                     |                      |
    |                                     v                      |
    |                             +----------------+             |
    |                             | Latent z       |             |
    |                             | ∈ R^256        |             |
    |                             +----------------+             |
    +===========================================================+
                                     |
                                     v
    +===========================================================+
    |                      DECODER (Diffusion)                   |
    |                                                            |
    |  Forward Process (Training):                               |
    |  x_0 -> x_1 -> x_2 -> ... -> x_T  (add noise)             |
    |                                                            |
    |  Reverse Process (Generation):                             |
    |  x_T -> x_{T-1} -> ... -> x_0  (denoise)                  |
    |                                                            |
    |  +------------------------------------------------------+ |
    |  | Diffusion Model predicts:                            | |
    |  | - Node positions (fractional coordinates)            | |
    |  | - Node types (BB embeddings)                         | |
    |  | - Lattice parameters (a, b, c, α, β, γ)             | |
    |  +------------------------------------------------------+ |
    |                                                            |
    +===========================================================+

    TRAINING LOSS:
    L = L_recon + β·L_KL + L_diffusion
        ^          ^         ^
    reconstruction  KL     denoising
    loss        divergence  score matching


2.3 NH3 PREDICTION HEAD TRAINING
--------------------------------------------------------------------------------
SCRIPT: scripts/train_nh3_head.py
CHECKPOINT: raw_nh3_core/nh3_head_best_final.pt

    STEP 1: Export Latent Vectors
    +-----------------------------------------------------------+
    |  For each MOF with known NH3 uptake:                      |
    |                                                            |
    |  CIF file --> MOFDiff Encoder --> Latent z ∈ R^256        |
    |                                                            |
    |  Save: {z, NH3_uptake} pairs                              |
    |  Output: raw_nh3_core/nh3_latent_dataset.pt               |
    +-----------------------------------------------------------+

    STEP 2: Train Predictor (SVR or MLP)
    +-----------------------------------------------------------+
    |                                                            |
    |  +--------------+    +--------------+    +-------------+  |
    |  | Latent z     | -> | SVR/MLP      | -> | NH3 uptake  |  |
    |  | (256-dim)    |    | Predictor    |    | (mmol/g)    |  |
    |  +--------------+    +--------------+    +-------------+  |
    |                                                            |
    |  For Gradient Optimization (MLP Architecture):            |
    |  +------------------------------------------------------+ |
    |  |  Input: z (256) ------------------------------------+ | |
    |  |         |                                            | | |
    |  |  Linear(256->512) + BatchNorm + ReLU + Dropout(0.3) | | |
    |  |         |                                            | | |
    |  |  Linear(512->256) + BatchNorm + ReLU + Dropout(0.2) | | |
    |  |         |                                            | | |
    |  |  Linear(256->128) + BatchNorm + ReLU                | | |
    |  |         |                                            | | |
    |  |  Linear(128->1) ------------------------------------|+ | |
    |  |         |                                              | |
    |  |  Output: NH3 uptake prediction                        | |
    |  +------------------------------------------------------+ |
    |                                                            |
    |  Training: MSE Loss on normalized targets                 |
    |  CV MAE: ~0.49 mmol/g                                     |
    |                                                            |
    +-----------------------------------------------------------+


================================================================================
                         PHASE 3: GENERATION (Inference)
================================================================================

3.1 LATENT SPACE SAMPLING
--------------------------------------------------------------------------------
Three Approaches:

    A) RANDOM SAMPLING (No guidance)
    +-----------------------------------------------------------+
    |  z ~ N(0, I)     # Sample from standard normal            |
    |  z ∈ R^256                                                |
    +-----------------------------------------------------------+

    B) SCREENING (Target NH3)
    +-----------------------------------------------------------+
    |  1. Generate N candidates: z_1, z_2, ..., z_N             |
    |  2. Predict NH3 for each: y_i = f(z_i)                    |
    |  3. Select closest to target: argmin|y_i - target|        |
    +-----------------------------------------------------------+

    C) GRADIENT OPTIMIZATION (Precise targeting) [RECOMMENDED]
    +-----------------------------------------------------------+
    |  1. Initialize: z_0 ~ N(0, I)                             |
    |  2. For t = 1 to T:                                       |
    |     a. Normalize: z_norm = (z - X_mean) / X_std           |
    |     b. Predict: y = MLP(z_norm) * y_std + y_mean          |
    |     c. Loss: L = (y - target)^2 + λ||z||^2                |
    |     d. Gradient: ∇_z L                                    |
    |     e. Update: z = z - lr · ∇_z L                         |
    |  3. Return optimized z                                    |
    +-----------------------------------------------------------+


3.2 DIFFUSION DECODING (z --> CG MOF)
--------------------------------------------------------------------------------
SCRIPT: model.sample() in mofdiff/model/

    INPUT: Latent vector z ∈ R^256

    +-----------------------------------------------------------+
    |  REVERSE DIFFUSION PROCESS (2000 steps)                   |
    |                                                            |
    |  t=2000        t=1500        t=1000        t=500    t=0   |
    |    o------------o------------o------------o--------o      |
    |   noise                                           clean   |
    |                                                            |
    |  For t = T, T-1, ..., 1:                                  |
    |    1. Predict noise: ε_θ(x_t, t, z)                       |
    |    2. Estimate x_{t-1} using DDPM formula                 |
    |    3. Add scheduled noise (if t > 1)                      |
    |                                                            |
    +-----------------------------------------------------------+

    The diffusion model generates:
    - Fractional coordinates: pos ∈ [0,1]^{N×3}
    - Node embeddings: h ∈ R^{N×128} (BB type)
    - Lattice parameters: (a, b, c, α, β, γ)

    OUTPUT: Coarse-Grained MOF Structure


3.3 BUILDING BLOCK MATCHING
--------------------------------------------------------------------------------
SCRIPT: mofdiff/common/atomic_utils.py - arrange_decoded_mofs

    Problem: Diffusion outputs continuous BB embeddings
    Solution: Match to nearest real BB in embedding space

    +-----------------------------------------------------------+
    |  For each generated node embedding h_i:                   |
    |                                                            |
    |  1. Query KD-Tree of all BB embeddings                    |
    |     nearest_bb = kdtree.query(h_i)                        |
    |                                                            |
    |  2. Replace with actual BB structure                      |
    |     node_i --> BB_structure[nearest_bb]                   |
    |                                                            |
    |  BB Embedding Space:                                       |
    |      o  <-- Generated embedding                           |
    |     /|\                                                    |
    |    / | \                                                   |
    |   o  o  o  <-- Real BB embeddings                         |
    |   |                                                        |
    |   +-- Nearest neighbor selected                           |
    |                                                            |
    +-----------------------------------------------------------+

    OUTPUT: CG MOF with matched real building blocks


================================================================================
                         PHASE 4: POST-PROCESSING
================================================================================

4.1 ASSEMBLY (CG --> Atomic)
--------------------------------------------------------------------------------
SCRIPT: mofdiff/scripts/assemble.py

    INPUT: Coarse-Grained MOF (BB positions + types)

    STEP 1: Feasibility Check
    +-----------------------------------------------------------+
    |  - Check connection compatibility                          |
    |  - Verify BB types can connect                            |
    |  - If failed --> skip this sample                         |
    +-----------------------------------------------------------+

    STEP 2: Annealed Optimization (3 rounds)
    +-----------------------------------------------------------+
    |  Goal: Find BB orientations that minimize bond strain     |
    |                                                            |
    |  For round r = 1, 2, 3:                                   |
    |    σ = [3.0, 1.5, 0.3]  (decreasing temperature)          |
    |    max_neighbors = [30, 15, 1]                            |
    |                                                            |
    |    Optimize:                                               |
    |    min Σ ||connection_point_i - connection_point_j||^2    |
    |    s.t. BBs properly oriented                             |
    |                                                            |
    |  Uses scipy.optimize with L-BFGS-B                        |
    +-----------------------------------------------------------+

    STEP 3: Atomic Structure Assembly
    +-----------------------------------------------------------+
    |                                                            |
    |  CG Position + BB Template + Orientation                  |
    |       |           |            |                          |
    |  +------------------------------------------+             |
    |  |  Place all atoms from BB template        |             |
    |  |  at correct positions in unit cell       |             |
    |  +------------------------------------------+             |
    |                                                            |
    |  Before:     After:                                        |
    |   [BB1]       H   H                                        |
    |     |          \ /                                         |
    |   [BB2]    O=C-C=O                                        |
    |     |          |                                           |
    |   [BB3]      Cu-Cu                                        |
    |                |                                           |
    |            O=C-C=O                                        |
    |              / \                                           |
    |             H   H                                          |
    |                                                            |
    +-----------------------------------------------------------+

    OUTPUT: Atomic MOF structure (before relaxation)


4.2 CIF FILE GENERATION
--------------------------------------------------------------------------------
SCRIPT: mofdiff/common/atomic_utils.py - mof2cif_with_bonds

    Convert assembled MOF to CIF format:

    data_I
    _chemical_name_common  'sample_0'
    _cell_length_a  7.68164
    _cell_length_b  9.09222
    _cell_length_c  18.29678
    _cell_angle_alpha  92.67198
    _cell_angle_beta   90.50841
    _cell_angle_gamma  94.63037
    _space_group_name_H-M_alt  'P 1'

    loop_
    _atom_site_label
    _atom_site_fract_x
    _atom_site_fract_y
    _atom_site_fract_z
    _atom_site_type_symbol
    Cu0   0.70755  0.90195  0.63495  Cu
    Cu1   0.36384  0.85488  0.64774  Cu
    ...

    loop_
    _geom_bond_atom_site_label_1
    _geom_bond_atom_site_label_2
    _geom_bond_distance
    Cu0  Cu1  2.65457
    ...


4.3 STRUCTURE RELAXATION
--------------------------------------------------------------------------------
SCRIPTS: simple_relax.py or uff_relax.py

    Purpose: Optimize geometry to reduce strain

    OPTION A: Simple Relaxation (Primitive Structure)
    +-----------------------------------------------------------+
    |  1. Load CIF with pymatgen                                |
    |  2. Get primitive structure                                |
    |  3. Save optimized CIF                                    |
    |                                                            |
    |  Quick but minimal optimization                           |
    +-----------------------------------------------------------+

    OPTION B: UFF Relaxation (Force Field)
    +-----------------------------------------------------------+
    |  1. Load structure into LAMMPS                            |
    |  2. Apply Universal Force Field (UFF)                     |
    |  3. Energy minimization:                                  |
    |     min E = E_bond + E_angle + E_torsion + E_vdw         |
    |  4. Save relaxed structure                                |
    |                                                            |
    |  More accurate but slower                                 |
    +-----------------------------------------------------------+

    Before Relaxation:        After Relaxation:
     (strained bonds)          (equilibrium geometry)
          /\                         /\
         /  \                       /  \
        o----o       -->           o----o
       /      \                   /      \
      o        o                 o        o


4.4 VALIDATION (Optional)
--------------------------------------------------------------------------------
SCRIPT: mofdiff/scripts/uff_relax.py (with zeo++ / mofid)

    VALIDATION CHECKS:

    1. Zeo++ Structural Properties:
       - Pore volume
       - Surface area
       - Pore limiting diameter
       - Largest cavity diameter

    2. MOFid Topology Verification:
       - Extract topology code
       - Verify valid framework
       - Check BB connectivity

    3. Validity Criteria:
       - No overlapping atoms
       - Reasonable bond lengths
       - Connected framework
       - Positive pore volume

    OUTPUT: valid_mof_paths.json


================================================================================
                         COMPLETE PIPELINE DIAGRAM
================================================================================

+===============================================================================+
|                              TRAINING (One-time)                               |
+===============================================================================+
|                                                                                |
|  CIF Files + NH3 Data                                                          |
|       |                                                                        |
|       v                                                                        |
|  +----------------+    +----------------+    +----------------+                |
|  | Preprocessing  | -> | BB Encoder     | -> | MOFDiff VAE    |                |
|  | (CG + Graph)   |    | Training       |    | + Diffusion    |                |
|  +----------------+    +----------------+    +-------+--------+                |
|                                                      |                         |
|                                                      v                         |
|                                              +----------------+                |
|                                              | NH3 Head       |                |
|                                              | Training       |                |
|                                              +----------------+                |
|                                                                                |
+===============================================================================+
                                       |
                                       v
+===============================================================================+
|                              INFERENCE (Per Request)                           |
+===============================================================================+
|                                                                                |
|  User Input: target_nh3 = 2.0 mmol/g, n_samples = 5                           |
|       |                                                                        |
|       v                                                                        |
|  +--------------------------------------------------------------------+       |
|  | STEP 1: Latent Optimization                                        |       |
|  |                                                                     |       |
|  |  z_0 ~ N(0,I)  ------------------------------------------------+   |       |
|  |       |                                                         |   |       |
|  |       v                                                         |   |       |
|  |  +---------+    +---------+    +---------+                     |   |       |
|  |  | MLP     | -> | Loss    | -> | Update  | --------------------+   |       |
|  |  | Predict |    | Compute |    | z       |      (iterate 500x)     |       |
|  |  +---------+    +---------+    +---------+                         |       |
|  |       |                                                             |       |
|  |       v                                                             |       |
|  |  z_optimized (NH3 ≈ 2.0 mmol/g)                                    |       |
|  +--------------------------------------------------------------------+       |
|       |                                                                        |
|       v                                                                        |
|  +--------------------------------------------------------------------+       |
|  | STEP 2: Diffusion Decoding                                         |       |
|  |                                                                     |       |
|  |  z --> Reverse Diffusion (2000 steps) --> CG MOF                   |       |
|  |        (positions, BB embeddings, lattice)                         |       |
|  |                                                                     |       |
|  +--------------------------------------------------------------------+       |
|       |                                                                        |
|       v                                                                        |
|  +--------------------------------------------------------------------+       |
|  | STEP 3: BB Matching                                                |       |
|  |                                                                     |       |
|  |  CG embeddings --> KD-Tree query --> Real BB structures            |       |
|  |                                                                     |       |
|  +--------------------------------------------------------------------+       |
|       |                                                                        |
|       v                                                                        |
|  +--------------------------------------------------------------------+       |
|  | STEP 4: Assembly                                                   |       |
|  |                                                                     |       |
|  |  Feasibility Check --> Annealed Optimization --> Atomic Structure  |       |
|  |                                                                     |       |
|  +--------------------------------------------------------------------+       |
|       |                                                                        |
|       v                                                                        |
|  +--------------------------------------------------------------------+       |
|  | STEP 5: Relaxation & Output                                        |       |
|  |                                                                     |       |
|  |  Atomic MOF --> UFF/Primitive Relaxation --> CIF Files             |       |
|  |                                                                     |       |
|  +--------------------------------------------------------------------+       |
|       |                                                                        |
|       v                                                                        |
|  OUTPUT: nh3_gradient_2.0/                                                    |
|  ├── samples.pt         (latent vectors + predictions)                        |
|  ├── assembled.pt       (assembled structures)                                |
|  ├── cif/               (assembled CIF files)                                 |
|  │   ├── sample_0.cif                                                         |
|  │   ├── sample_1.cif                                                         |
|  │   └── ...                                                                  |
|  └── relaxed/           (relaxed CIF files)                                   |
|      ├── sample_0_relaxed.cif                                                 |
|      └── ...                                                                  |
|                                                                                |
+===============================================================================+


================================================================================
                         COMMAND REFERENCE
================================================================================

# 1. Random sampling (no guidance)
python mofdiff/scripts/sample.py \
    --model_path pretrained/mofdiff_ckpt \
    --bb_cache_path pretrained/bb_emb_space.pt \
    --n_samples 5

# 2. NH3-guided screening
python scripts/sample_nh3_target.py \
    --target_nh3 1.5 \
    --n_samples 5 \
    --n_candidates 5000 \
    --assemble --relax

# 3. NH3 gradient optimization (precise) [RECOMMENDED]
python scripts/sample_nh3_gradient.py \
    --target_nh3 2.0 \
    --n_samples 5 \
    --n_init 30 \
    --steps 500 \
    --assemble --relax

# 4. Hybrid approach (screening + gradient refinement)
python scripts/sample_nh3_hybrid.py \
    --target_nh3 1.0 \
    --n_samples 5 \
    --n_screening 5000 \
    --top_k_refine 50 \
    --assemble --relax

# 5. Assembly only
python mofdiff/scripts/assemble.py \
    --input samples.pt

# 6. Relaxation only
python scripts/simple_relax.py \
    --input_dir output_folder/


================================================================================
                         KEY FILES & CHECKPOINTS
================================================================================

PRETRAINED MODELS:
├── pretrained/
│   ├── mofdiff_ckpt/           # Main MOFDiff model
│   ├── bbencoder_ckpt/         # Building block encoder
│   └── bb_emb_space.pt         # BB embedding cache (for KD-Tree)

NH3 HEAD:
├── raw_nh3_core/
│   ├── nh3_head_best_final.pt  # SVR predictor
│   ├── nh3_predictor_mlp.pt    # MLP predictor (for gradients)
│   ├── nh3_latent_dataset.pt   # Training data
│   └── nh3_core_structured.csv # NH3 uptake labels

SCRIPTS:
├── scripts/
│   ├── sample_nh3.py           # NH3-guided sampling
│   ├── sample_nh3_target.py    # Target NH3 screening
│   ├── sample_nh3_gradient.py  # Gradient optimization
│   ├── sample_nh3_hybrid.py    # Hybrid approach
│   └── simple_relax.py         # Structure relaxation

CONFIG:
├── conf/
│   ├── mofdiff.yaml            # Main config
│   └── nh3_mofdiff.yaml        # NH3-specific config


================================================================================
                         COMPARISON OF METHODS
================================================================================

+------------------+-------------------+-------------------+-------------------+
|     Method       |     Random        |    Screening      |    Gradient       |
+------------------+-------------------+-------------------+-------------------+
| Approach         | z ~ N(0,I)        | Generate many,    | Iteratively       |
|                  |                   | pick best         | optimize z        |
+------------------+-------------------+-------------------+-------------------+
| NH3 Targeting    | None              | Approximate       | Precise           |
+------------------+-------------------+-------------------+-------------------+
| Predictor        | Not used          | SVR (any)         | MLP (must be      |
|                  |                   |                   | differentiable)   |
+------------------+-------------------+-------------------+-------------------+
| Speed            | Fast              | Fast              | Slower            |
+------------------+-------------------+-------------------+-------------------+
| Achievable       | Random            | Limited by        | Can hit exact     |
| NH3 Range        |                   | sampling luck     | target            |
+------------------+-------------------+-------------------+-------------------+
| Best For         | Exploration       | Quick targeting   | Precise control   |
+------------------+-------------------+-------------------+-------------------+


================================================================================
                         NH3 UPTAKE DATA RANGE
================================================================================

From training data (raw_nh3_core/nh3_core_structured.csv):

    Min:    0.003 mmol/g
    Max:    14.9 mmol/g
    Mean:   2.5 mmol/g
    Median: 1.4 mmol/g
    Std:    2.8 mmol/g

    Percentiles:
    10th:   0.04 mmol/g
    25th:   0.13 mmol/g
    50th:   1.41 mmol/g
    75th:   4.23 mmol/g
    90th:   6.73 mmol/g

    Reliable prediction range (MLP): ~0.0 - 2.5 mmol/g


================================================================================
                                   END
================================================================================
